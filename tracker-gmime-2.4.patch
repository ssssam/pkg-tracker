diff -upr tracker-0.6.6.old/src/trackerd/tracker-email-evolution.c tracker-0.6.6/src/trackerd/tracker-email-evolution.c
--- tracker-0.6.6.old/src/trackerd/tracker-email-evolution.c	2008-02-28 23:49:53.000000000 +0000
+++ tracker-0.6.6/src/trackerd/tracker-email-evolution.c	2008-12-15 21:31:43.000000000 +0000
@@ -1450,7 +1450,7 @@ load_uri_and_status_of_mbox_mail_message
 	g_return_if_fail (g_m_message);
 	g_return_if_fail (msg);
 
-	field = g_mime_message_get_header (g_m_message, "X-Evolution");
+	field = g_mime_object_get_header (GMIME_OBJECT (g_m_message), "X-Evolution");
 
 	g_return_if_fail (field);
 
@@ -2478,27 +2478,28 @@ break_multipart_loop:
 static GSList *
 add_persons_from_internet_address_list_string_parsing (GSList *list, const gchar *s)
 {
-	InternetAddressList *addrs_list, *tmp;
+	InternetAddressList *addrs_list;
+	int i, count;
 
 	g_return_val_if_fail (s, NULL);
 
-	addrs_list = internet_address_parse_string (s);
+	addrs_list = internet_address_list_parse_string (s);
+	count = internet_address_list_length (addrs_list);
 
-	for (tmp = addrs_list; tmp; tmp = tmp->next) {
+	for (i = 0; i < count; i++) {
 		MailPerson *mp;
+		InternetAddress *addr;
 
 		mp = email_allocate_mail_person ();
+		addr = internet_address_list_get_address (addrs_list, i);
 
-		mp->addr = g_strdup (tmp->address->value.addr);
-		if(tmp->address->name)
-                	mp->name = g_strdup (tmp->address->name);
-		else
-			mp->name = g_strdup (tmp->address->value.addr);
+		mp->name = g_strdup (internet_address_get_name (addr));
+		mp->addr = internet_address_to_string (addr, FALSE);
 
 		list = g_slist_prepend (list, mp);
 	}
 
-	internet_address_list_destroy (addrs_list);
+	g_object_unref (addrs_list);
 
 	return list;
 }
diff -upr tracker-0.6.6.old/src/trackerd/tracker-email-kmail.c tracker-0.6.6/src/trackerd/tracker-email-kmail.c
--- tracker-0.6.6.old/src/trackerd/tracker-email-kmail.c	2008-01-15 04:05:03.000000000 +0000
+++ tracker-0.6.6/src/trackerd/tracker-email-kmail.c	2008-12-15 21:11:22.000000000 +0000
@@ -787,7 +787,7 @@ load_uri_of_mbox_mail_message (GMimeMess
            This line is at the beginning of each header but GMIME does not give access to it so we reproduce it.
         */
 
-        field = g_mime_message_get_header (g_m_message, "From");
+        field = g_mime_object_get_header (g_m_message, "From");
 
         tmp_from = g_strdup (field);
 
@@ -862,10 +862,10 @@ fill_uri_with_uid_for_imap (GMimeMessage
 
         mail_msg->uri = NULL;
 
-        /* Currently, "g_mime_message_get_header(g_m_message, "X-UID")" does not work because GMIME
+        /* Currently, "g_mime_object_get_header(g_m_message, "X-UID")" does not work because GMIME
            only handles RFC822 headers... So we have to search X-UID header ourself. */
 
-        headers = g_mime_message_get_headers (g_m_message);
+        headers = g_mime_object_get_headers (g_m_message);
         g_return_if_fail (headers);
 
         pos_uid = strstr (headers, "X-UID");
diff -upr tracker-0.6.6.old/src/trackerd/tracker-email-thunderbird.c tracker-0.6.6/src/trackerd/tracker-email-thunderbird.c
--- tracker-0.6.6.old/src/trackerd/tracker-email-thunderbird.c	2008-01-15 04:05:03.000000000 +0000
+++ tracker-0.6.6/src/trackerd/tracker-email-thunderbird.c	2008-12-15 21:34:18.000000000 +0000
@@ -418,26 +418,27 @@ free_parser_data (gpointer user_data)
 static GSList *
 add_persons_from_internet_address_list_string_parsing (GSList *list, const gchar *s)
 {
-	InternetAddressList *addrs_list, *tmp;
+	InternetAddressList *addrs_list;
+	int i, count;
 
 	g_return_val_if_fail (s, NULL);
 
-	addrs_list = internet_address_parse_string (s);
+	addrs_list = internet_address_list_parse_string (s);
+	count = internet_address_list_length (addrs_list);
 
-	for (tmp = addrs_list; tmp; tmp = tmp->next) {
+
+	for (i = 0; i < count; i++) {
 		MailPerson *mp = email_allocate_mail_person ();
+		InternetAddress *addr;
 
-		mp->addr = g_strdup (tmp->address->value.addr);
-                if(tmp->address->name) {
-                        mp->name = g_strdup (tmp->address->name);
-                } else {
-                        mp->name = g_strdup (tmp->address->value.addr);
-                }
+		addr = internet_address_list_get_address (addrs_list, i);
+		mp->name = g_strdup (internet_address_get_name (addr));
+		mp->addr = internet_address_to_string (addr, FALSE);
 
 		list = g_slist_prepend (list, mp);
 	}
 
-	internet_address_list_destroy (addrs_list);
+	g_object_unref (addrs_list);
 
 	return list;
 }
diff -upr tracker-0.6.6.old/src/trackerd/tracker-email-utils.c tracker-0.6.6/src/trackerd/tracker-email-utils.c
--- tracker-0.6.6.old/src/trackerd/tracker-email-utils.c	2008-02-29 00:32:16.000000000 +0000
+++ tracker-0.6.6/src/trackerd/tracker-email-utils.c	2008-12-15 21:28:50.000000000 +0000
@@ -46,8 +46,8 @@ extern Tracker *tracker;
 static GMimeStream *new_gmime_stream_from_file	(const gchar *path, gint flags, off_t start, off_t end);
 
 static GSList *	add_gmime_references		(GSList *list, GMimeMessage *message, const gchar *header);
-static GSList *	add_recipients			(GSList *list, GMimeMessage *message, const gchar *type);
-static void	find_attachment			(GMimeObject *obj, gpointer data);
+static GSList *	add_recipients			(GSList *list, GMimeMessage *message, GMimeRecipientType type);
+static void	find_attachment			(GMimeObject *parent, GMimeObject *obj, gpointer data);
 
 
 
@@ -491,6 +491,124 @@ email_free_mail_message (MailMessage *ma
 	g_slice_free (MailMessage, mail_msg);
 }
 
+static GMimeObject *
+handle_multipart_alternative (GMimeMultipart *multipart, gboolean want_plain, gboolean *is_html)
+{
+	GMimeObject *mime_part, *text_part = NULL;
+	GMimeContentType *type;
+	int count, i;
+
+	count = g_mime_multipart_get_count (multipart);
+	for (i = 0; i < count ; i++) {
+		mime_part = g_mime_multipart_get_part (multipart, i);
+
+		type = g_mime_object_get_content_type (GMIME_OBJECT (mime_part));
+		if (g_mime_content_type_is_type (type, "text", "*")) {
+			if (!text_part || !g_ascii_strcasecmp (type->subtype, want_plain ? "plain" : "html")) {
+				*is_html = !g_ascii_strcasecmp (type->subtype, "html");
+				text_part = mime_part;
+			}
+		}
+	}
+
+	return text_part;
+}
+
+static GMimeObject *
+handle_multipart_mixed (GMimeMultipart *multipart, gboolean want_plain, gboolean *is_html)
+{
+	GMimeObject *mime_part, *text_part = NULL;
+	GMimeContentType *type, *first_type = NULL;
+	GList *subpart;
+	int count, i;
+
+	count = g_mime_multipart_get_count (multipart);
+	for (i = 0; i < count ; i++) {
+		mime_part = g_mime_multipart_get_part (multipart, i);
+
+		type = g_mime_object_get_content_type (mime_part);
+		if (GMIME_IS_MULTIPART (mime_part)) {
+			multipart = GMIME_MULTIPART (mime_part);
+			if (g_mime_content_type_is_type (type, "multipart", "alternative")) {
+				mime_part = handle_multipart_alternative (multipart, want_plain, is_html);
+				if (mime_part)
+					return mime_part;
+			} else {
+				mime_part = handle_multipart_mixed (multipart, want_plain, is_html);
+				if (mime_part && !text_part)
+					text_part = mime_part;
+			}
+		} else if (g_mime_content_type_is_type (type, "text", "*")) {
+			if (!g_ascii_strcasecmp (type->subtype, want_plain ? "plain" : "html")) {
+				/* we got what we came for */
+				*is_html = !g_ascii_strcasecmp (type->subtype, "html");
+				return mime_part;
+			}
+
+			/* if we haven't yet found a text part or if it is a type we can
+			   1514 	* understand and it is the first of that type, save it */
+			if (!text_part || (!g_ascii_strcasecmp (type->subtype, "plain") && (first_type &&
+											    g_ascii_strcasecmp (type->subtype, first_type->subtype) != 0))) {
+				*is_html = !g_ascii_strcasecmp (type->subtype, "html");
+				text_part = mime_part;
+				first_type = type;
+			}
+		}
+
+		subpart = subpart->next;
+	}
+
+	return text_part;
+}
+
+static char *
+tracker_mime_message_get_body (const GMimeMessage *message, gboolean want_plain, gboolean *is_html)
+{
+	GMimeObject *mime_part = NULL;
+	GMimeContentType *type;
+	GMimeMultipart *multipart;
+	char *body = NULL;
+
+	g_return_val_if_fail (GMIME_IS_MESSAGE (message), NULL);
+	g_return_val_if_fail (is_html != NULL, NULL);
+
+	type = g_mime_object_get_content_type (message->mime_part);
+	if (GMIME_IS_MULTIPART (message->mime_part)) {
+		/* let's see if we can find a body in the multipart */
+		multipart = GMIME_MULTIPART (message->mime_part);
+		if (g_mime_content_type_is_type (type, "multipart", "alternative"))
+			mime_part = handle_multipart_alternative (multipart, want_plain, is_html);
+		else
+			mime_part = handle_multipart_mixed (multipart, want_plain, is_html);
+	} else if (g_mime_content_type_is_type (type, "text", "*")) {
+		/* this *has* to be the message body */
+		if (g_mime_content_type_is_type (type, "text", "html"))
+			*is_html = TRUE;
+		else
+			*is_html = FALSE;
+
+		mime_part = message->mime_part;
+	}
+
+	if (mime_part != NULL) {
+		GMimeDataWrapper *data_wrapper;
+		GMimeStream *mime_stream;
+		gint64 len;
+
+		data_wrapper = g_mime_part_get_content_object (GMIME_PART (mime_part));
+		
+		mime_stream = g_mime_data_wrapper_get_stream (data_wrapper);
+		len = g_mime_stream_length (mime_stream);
+		body = g_malloc0 (len + 1);
+		g_mime_stream_read (mime_stream, body, len);
+		g_object_unref (mime_stream);
+		g_object_unref (data_wrapper);
+	}
+
+	return body;
+}
+
+
 
 MailMessage *
 email_mail_file_parse_next (MailFile *mf, ReadMailHelperFct read_mail_helper, gpointer read_mail_user_data)
@@ -539,7 +657,7 @@ email_mail_file_parse_next (MailFile *mf
 
 	mail_msg->subject = g_strdup (g_mime_message_get_subject (g_m_message));
 
-	mail_msg->body = g_mime_message_get_body (g_m_message, TRUE, &is_html);
+	mail_msg->body = tracker_mime_message_get_body (g_m_message, TRUE, &is_html);
 	mail_msg->content_type = g_strdup (is_html ? "text/html" : "text/plain");
 
 	if (read_mail_helper) {
@@ -549,7 +667,7 @@ email_mail_file_parse_next (MailFile *mf
 	mail_msg->attachments = NULL;
 
 	/* find then save attachments in sys tmp directory of Tracker and save entries in MailMessage struct */
-	g_mime_message_foreach_part (g_m_message, find_attachment, mail_msg);
+	g_mime_message_foreach (g_m_message, find_attachment, mail_msg);
 
 	g_object_unref (g_m_message);
 
@@ -786,23 +904,23 @@ email_decode_mail_attachment_to_file (co
 		return FALSE;
 	}
 
-	filtered_stream = g_mime_stream_filter_new_with_stream (stream_src);
+	filtered_stream = g_mime_stream_filter_new (stream_src);
 
 	switch (encoding) {
 		case MIME_ENCODING_BASE64:
-			filter = g_mime_filter_basic_new_type (GMIME_FILTER_BASIC_BASE64_DEC);
+			filter = g_mime_filter_basic_new (GMIME_CONTENT_ENCODING_BASE64, FALSE);
 			g_mime_stream_filter_add (GMIME_STREAM_FILTER (filtered_stream), filter);
 			g_object_unref (filter);
 			break;
 
 		case MIME_ENCODING_QUOTEDPRINTABLE:
-			filter = g_mime_filter_basic_new_type (GMIME_FILTER_BASIC_QP_DEC);
+			filter = g_mime_filter_basic_new (GMIME_CONTENT_ENCODING_QUOTEDPRINTABLE, FALSE);
 			g_mime_stream_filter_add (GMIME_STREAM_FILTER (filtered_stream), filter);
 			g_object_unref (filter);
 			break;
 
 		case MIME_ENCODING_UUENCODE:
-			filter = g_mime_filter_basic_new_type (GMIME_FILTER_BASIC_UU_ENC);
+			filter = g_mime_filter_basic_new (GMIME_CONTENT_ENCODING_UUENCODE, TRUE);
 			g_mime_stream_filter_add (GMIME_STREAM_FILTER (filtered_stream), filter);
 			g_object_unref (filter);
 			break;
@@ -913,7 +1031,7 @@ new_gmime_stream_from_file (const gchar 
 static GSList *
 add_gmime_references (GSList *list, GMimeMessage *message, const gchar *header)
 {
-	const gchar *tmp = g_mime_message_get_header (message, header);
+	const gchar *tmp = g_mime_object_get_header (GMIME_OBJECT (message), header);
 
 	if (tmp) {
 		GMimeReferences       *refs;
@@ -937,15 +1055,21 @@ add_gmime_references (GSList *list, GMim
 
 
 static GSList *
-add_recipients (GSList *list, GMimeMessage *message, const gchar *type)
+add_recipients (GSList *list, GMimeMessage *message, GMimeRecipientType type)
 {
-	const InternetAddressList *addrs_list;
+	InternetAddressList *addrs_list;
+	int i, count;
 
-	for (addrs_list = g_mime_message_get_recipients (message, type); addrs_list; addrs_list = addrs_list->next) {
+	addrs_list = g_mime_message_get_recipients (message, type);
+	count = internet_address_list_length (addrs_list);
+	for (i = 0; i < count; i++) {
+		InternetAddress *addr;
 		MailPerson *mp = email_allocate_mail_person ();
 
-		mp->name = g_strdup (addrs_list->address->name);
-		mp->addr = g_strdup (addrs_list->address->value.addr);
+		addr = internet_address_list_get_address (addrs_list, i);
+
+		mp->name = g_strdup (internet_address_get_name (addr));
+		mp->addr = g_strdup (internet_address_to_string (addr, FALSE));
 
 		list = g_slist_prepend (list, mp);
 	}
@@ -955,7 +1079,7 @@ add_recipients (GSList *list, GMimeMessa
 
 
 static void
-find_attachment (GMimeObject *obj, gpointer data)
+find_attachment (GMimeObject *parent, GMimeObject *obj, gpointer data)
 {
 	GMimePart   *part;
 	MailMessage *mail_msg;
@@ -969,8 +1093,8 @@ find_attachment (GMimeObject *obj, gpoin
 		GMimeMessage *g_msg = g_mime_message_part_get_message (GMIME_MESSAGE_PART (obj));
 
 		if (g_msg) {
-			g_mime_message_foreach_part (g_msg, find_attachment, data);
-			g_object_unref (g_msg);
+			g_mime_message_foreach (g_msg, find_attachment, data);
+			g_object_unref (obj);
 		}
 		return;
 
@@ -987,20 +1111,20 @@ find_attachment (GMimeObject *obj, gpoin
 
 	mail_msg = data;
 
-	content_disposition = g_mime_part_get_content_disposition (part);
+	content_disposition = g_mime_object_get_disposition (obj);
 
 	/* test whether it is a mail attachment */
 	if (content_disposition &&
 	    (strcmp (content_disposition, GMIME_DISPOSITION_ATTACHMENT) == 0 ||
 	     strcmp (content_disposition, GMIME_DISPOSITION_INLINE) == 0)) {
 
-		const GMimeContentType *content_type;
+		GMimeContentType       *content_type;
 		MailAttachment         *ma;
 		const gchar            *filename;
 		gchar                  *attachment_uri;
 		gint                   fd;
 
-		if (! (content_type = g_mime_part_get_content_type (part)))
+		if (! (content_type = g_mime_object_get_content_type (obj)))
 			return;
 
 		filename = g_mime_part_get_filename (part);
--- tracker-0.6.6.old/configure.ac	2008-03-03 04:13:34.000000000 +0000
+++ tracker-0.6.6/configure.ac	2008-12-15 21:10:17.000000000 +0000
@@ -65,7 +65,7 @@ AC_SUBST(PANGO_CFLAGS)
 AC_SUBST(PANGO_LIBS)
 
 # Check for GMime
-PKG_CHECK_MODULES(GMIME, [ gmime-2.0 >= $GMIME_REQUIRED ])
+PKG_CHECK_MODULES(GMIME, [ gmime-2.4 >= $GMIME_REQUIRED ])
 AC_SUBST(GMIME_CFLAGS)
 AC_SUBST(GMIME_LIBS)
 
